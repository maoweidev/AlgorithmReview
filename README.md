### 第二章 递归算法设计

***

### 第三章 分治法

#### 3.2 求解排序问题

#### 3.3 求解查找问题

***

##### 3.3.1 查找最大和次大问题

***问题描述***  

> 对于给定的含有n个元素的无序序列, 求这个序列中最大和次大的两个不同元素.

***问题求解***   

1. 若`a[low..high]`中只有一个元素, 则`max1 = a[low]`,`max2 = -INF(-∞)`.

2. 若`a[low..high]`中只有两个元素, 则`max1 = max{a[low], a[high]}`,`max2 = min{a[low], a[high]}`.

3. 若`a[low..high]`中只有两个以上元素, 按中间位置`mid = (low+high)/2`划分为`a[low..mid]`和`a[mid+1..high]`两个区间, 求出左区间的最大元素lmax1和次大元素lmax2, 求出右区间的最大元素rmax1和次大元素rmax2.
   若`lmax1>rmax1`, 则`max1 = lmax1`, `max2 = max{lmax2, rmax1}`; 否则`max1 = rmax1`, `max2=max{lmax1, rmax2}`.

***代码实现***

```C++
void solve(int a[], int low, int high, int &max1, int &max2)
{
    if(low == high)								
    {
        max1 = a[low];
        max2 = -INF;
    }
    else if(low == high-1)
    {
        max1 = max(a[low], a[high]);
        max2 = min(a[low], a[high]);
    }
    else
    {
        int mid = (low+high)/2;
        int lmax1, lmax2;
        solve(a, low, mid, lmax1, lmax2);
        int rmax1, rmax2;
        solve(a, mid+1, high, rmax1, rmax2);
        if(lmax1 > rmax1)
        {
            max1 = lmax1;
            max2 = max(lmax2, rmax1);
        }
        else
        {
            max1 = rmax1;
            max2 = max(rmax2, lmax1);
        }
    }
    
}
```

***

   ##### 3.3.3 寻找一个序列中第k小的元素

***问题描述***

>  对于给定的含有n个元素的无序序列, 求这个序列中第k(1 <= k <= n)小的元素.

***问题求解***

对于无序序列`a[s..t]`,在其中查找第k小的元素的过程如下:

1. 若`s >= t`, 即其中只有一个元素或没有任何元素, 如果`s=t`或`s=k-1`,表示只有一个元素且`a[k-1]`就是要求的结果, 返回`a[k-1]`.

2. 若`s < t`, 表示该序列中有两个或两个以上的元素, 以基准为中心将其划分为`a[s..i-1]`和`a[i+1..t]`两个子序列, 基准`a[i]`已归位, `a[s..i-1]`中的所有元素均小于`a[i]`, `a[i+1..t]`中的所有元素均大于`a[i]`, 也就是说`a[i]`是第`i+1`小的元素, 有三种情况:

   * 若`k-1 = i `, `a[i]`即为所求, 返回`a[i]`.

   * 若`k-1 < i `, 第k小的元素应在`a[s..i-1]`子序列中, 递归在该子序列中求解并返回其结果.

   * 若`k-1 > i `, 第k小的元素应在`a[i+1..t]`子序列中, 递归在该子序列中求解并返回其结果.


***代码实现***

```C++
int QuickSelect(int a[], int s, int t, int k)
{
    int i =s, j = t;
    int tmp;
    if(s < t)
    {
        tmp = a[s];							//用区间的第1个记录作为基准
        while(i != j)
        {
            while(j > i && a[j] >= tmp)		j--;
            a[i] = a[j];
             while(i < j && a[i] <= tmp)	i++;
            a[j] = a[i];
        }
        a[i] = tmp;
        if(k-1 == i)	return a[i];
        else if(k-1 < i)	return QuickSelect(a, s, i-1, k);
        else QuickSelect(a, i+1, t, k);
    }
    else if(s == t && s == k-1)	return a[k-1];
}
```

***

##### 3.3.4 寻找两个等长有序序列的中位数

***问题描述***

> 对与一个长度为n的有序序列(假设均为升序序列)`a[0..n-1]`, 处于中间位置的元素称为a的中位数. 例如, 若序列`a = (11, 13, 15, 17, 19)`, 其中位数是15, 若`b = (2, 4, 6, 8, 20) `, 其中位数是6. 两个等长有序序列的中位数是含它们所有元素的有序序列的中位数, 例如a, b两个有序序列的中位数为11. 设计一个算法求给定的两个有序序列的中位数.

***问题求解***

含有n个元素的有序序列`a[s..t]`,  当n为奇数时, 中位数出现在`m = ?(s+t)/2? `处; 当n为偶数时, 中位数下标有`m = ?(s+t)/2? `(下中位)和`m = ?(s+t)/2?+1`(上中位)两个, 为了简单仅考虑 中位数下标为`m = ?(s+t)/2? `.

采用二分法, 过程如下:

1. 分别求出a和b的中位数`a[m1]`和`b[m2]`.

2. 若`a[m1]=b[m2]`, 则`a[m1]`或`b[m2]`即为所求中位数, 算法结束.

3. 若`a[m1]<b[m2]`, 则舍弃序列a中的前半部分(较小的一半), 同时舍弃序列b中的后半部分(较大的一半), 要求舍弃的长度相等.

4. 若`a[m1]>b[m2]`, 则舍弃序列a中的后半部分(较大的一半), 同时舍弃序列b中的前半部分(较小的一半), 要求舍弃的长度相等.

   在保留的两个升序序列中重复上述过程直到两个序列中只含有一个元素时为止, 较小者即为所求的中位数.

***代码实现***

```C++
void prepart(int &s, int &t)			//求a[s..t]序列的前半子序列
{
    int m = (s+t)/2;
    t = m;
}
void postpart(int &s, int &t)			//求a[s..t]序列的后半子序列
{
    int m = (s+t)/2;
    if((s+t)%2==0)	s = m;				//序列中有奇数个元素
    else 			s = m+1;			//序列中有偶数个元素
}
int midnum(int a[], int s1, int t1, int b[], int s2, int t2)
{
    int m1, m2;
    if(s1==t1 && s2==t2)				//只有一个元素时返回较小者
    {
        return a[s1]<b[s2]?a[s1]:b[s2];
    }
    else
    {
        m1 = (s1+t1)/2;
        m2 = (s2+t2)/2;
        if(a[m1] == b[m2])	return a[m1];	//两中位数相等时返回该中位数
        if(a[m1] < b[m2])					//a[m1]<b[m2]时
        {
        	postpart(s1, t1);				//a取后半部分
            prepart(s2, t2);				//b取前半部分
            return midnum(a, s1, t1, b, s2, t2);
        }
        else								//a[m1]>b[m2]时
        {
            prepart(s1, t1);				//a取前半部分
            postpart(s2, t2);				//b取后半部分
            return midnum(a, s1, t1, b, s2, t2);
        }
    }
}
```

***

#### 3.4 求解组合问题

##### 3.4.1 求解最大连续子序列和问题

***问题描述***

>给定一个有n(n>=1)个整数的序列, 求出其中最大连续子序列的和. 例如序列`(-2, 11, -4, 13, -5, -2)`的最大子序列和为20. 规定一个序列的最大连续子序列和至少是0, 如果小于0, 其结果为0.

***问题求解***




#### 3.5 求解大整数乘法和矩阵乘法问题

***

### 第四章 蛮力法

#### 4.2 蛮力法的基本应用

#### 4.3 递归在蛮力法中的应用

***

### 第七章 贪心法

#### 7.2 求解活动安排问题

#### 7.3 求解背包问题

#### 7.4 求解最优装载问题

#### 7.5 求解田忌赛马问题

***问题描述***

> 齐威王与大将田忌赛马. 双方约定每人各出300匹马, 并且在上, 中, 下3个等级中各选一匹马参赛, 齐威王每个等级的马都比田忌的马略强. 现在双方各n匹马, 依次派出一匹马进行比赛, 每一轮获胜的一方将从输的一方得到200银币, 平局则不用出钱, 田忌已知所有马的速度值并可以安排出场顺序, 问他如何安排比赛获得的银币最多?

***问题求解***

采用常识性的贪心思路:

1. 田忌最快的马比齐威王最快的马快, 即`a[righta]>b[rightb]`,  则两者比赛(两个最快的马比赛), 田忌赢.

2. 田忌最快的马比齐威王最快的马慢,  即`a[righta]<b[rightb]`, 则选择田忌最慢的马与齐威王最快的马比赛, 田忌输.

3. 若田忌最快的马与齐威王最快的马速度相同, 即`a[righta]=b[rightb]`, 又分以下三种情况:

   * 田忌最慢的马比齐威王最慢的马快, 即`a[lefta]>b[leftb]`,  则两者比赛(两个最慢的马比赛), 田忌赢.

   * 田忌最慢的马比齐威王最慢的马慢, 且田忌最慢的马比齐威王最快的马慢, 即`a[lefta]<=b[leftb]`且`a[lefta]<b[rightb]`,则选择田忌最慢的马与齐威王最快的马比赛, 田忌输.

   * 其他情况, 即`a[righta]=b[rightb]`且`a[lefta]<=b[leftb]`且`a[lefta]>=b[rightb]`, 则`a[lefta]>=b[rightb]=a[righta] `,即`b[leftb]=b[rightb]`, 说明比赛区间所有的马速度全部相同, 任何两匹马比赛都没有输赢.

***代码实现***

```C++
define MAX 1001
int n;
int a[MAX];
int b[MAX];
int ans;
void solve()
{
	sort(a,a+n);
    sort(b,b+n);
    ans=0;
    int lefta=0, leftb=0;
    int righta=n-1, rightb=n-1;
    while(lefta<=righta)
    {
        if(a[righta]>b[rightb])				//田忌最快的马比齐威王最快的马快
        {
            ans+=200;
            righta--;
            rightb--;
        }
        else if(a[righta]<b[rightb])		//田忌最快的马比齐威王最快的马慢
        {
            ans-=200;
            lefta++;
            rightb--;
        }
        else								//若田忌最快的马与齐威王最快的马速度相同
        {
            if(a[lefta]>b[leftb])			//田忌最慢的马比齐威王最慢的马快
            {
                ans+=200;
                lefta++;
                leftb++;
            }
            else							//选择田忌最慢的马与齐威王最快的马比赛
            {
                if(a[lefta]<b[rightb])	ans-=200;
                lefta++;
                rightb--;
            }
        }
    }
}
```

***

#### 7.6 求解多机调度问题

***问题描述***









******

#### 7.7 哈夫曼编码

#### 7.8 求解流水作业调度问题

***

### 第八章 动态规划

#### 8.2 求解整数拆分问题

#### 8.3 求解最大连续子序列和问题

***问题描述***

> 给定一个有n(n>=1)个整数的序列, 求出其中最大连续子序列的和. 例如序列`(-2, 11, -4, 13, -5, -2)`的最大子序列和为20. 规定一个序列的最大连续子序列和至少是0, 如果小于0, 其结果为0.

***问题求解***




#### 8.4 求解三角形最小路径问题

#### 8.5 求解最长公共子序列问题

***问题描述***

> 字符序列的子序列是指从给定字符序列中随意地(不一定连续)去掉若干个字符(可能一个也不去掉)后所形成的字符序列. 令给定的字符序列`X = (x0,x1,...,xm-1)`, 序列`Y= (y0,y1,...,yk-1)`是X的子序列, 存在X的一个严格递增下标序列`(i0,i1,...,ik-1)`,使得对所有的`j=0,1,...,k-1`有`xij=yj`. 例如, `X = (a,b,c,b,d,a,b)`, `Y = (b,c,d,b)`是X的一个子序列.
>
> 给定两个子序列A和B, 称序列Z是A和B的公共子序列是指Z同是A和B的子序列.
>
> 该问题是求两序列A和B的**最长公共子序列**.

***问题求解***

1. 若`a[m-1] = b[n-1]`, 则进一步解决一个子问题, 找`(a0,a1,..am-2)`和`(b0,b1,...,bm-2)`的一个最长公共子序列.

2. 若`a[m-1] != b[n-1]`, 则要解决两个子问题, 找出`(a0,a1,..am-2)`和`(b0,b1,...,bn-1)`的一个最长公共子序列, 并找`(a0,a1,..am-1)`和`(b0,b1,...,bn-2)`的一个最长公共子序列, 再取两者中的较长者作为A和B的最长公共子序列.

   采用动态规划法, 定义二维动态数组`dp`, 其中`dp[i][j]`为子序列`(a0,a1,...,ai-1)`和`(b0,b1,...,bj-1)`的最长公共子序列的长度. 每考虑一个字符`a[i]`或`b[j]`都为动态规划的一个阶段. 对应的状态转移方程如下:

   ```C++
   dp[i][j]=0									//i=0或j=0, 边界条件
   dp[i][j]=dp[i-1][j-1]+1						//a[i-1]=b[j-1]
   dp[i][j]=MAX(dp[i][j-1], dp[i-1][j])		//a[i-1]!=b[j-1]
   ```

   `dp[m][n]`为最终结果.

   ***

#### 8.6 求解最长递增子序列问题

#### 8.7 求解编辑距离问题

#### 8.8 求解0/1背包问题

#### 8.9 求解完全背包问题

#### 8.10 求解资源分配问题

#### 8.11 求解会议安排问题

#### 8.12 滚动数组 









