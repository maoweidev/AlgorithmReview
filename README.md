# AlgorithmReview
### 第二章 递归算法设计

***

### 第三章 分治法

#### 3.2 求解排序问题

#### 3.3 求解查找问题

***

##### 3.3.1 查找最大和次大问题

***问题描述***  

> 对于给定的含有n个元素的无序序列, 求这个序列中最大和次大的两个不同元素.

***问题求解***   

1. 若`a[low..high]`中只有一个元素, 则`max1 = a[low]`,`max2 = -INF(-∞)`.

2. 若`a[low..high]`中只有两个元素, 则`max1 = max{a[low], a[high]}`,`max2 = min{a[low], a[high]}`.

3. 若`a[low..high]`中只有两个以上元素, 按中间位置`mid = (low+high)/2`划分为`a[low..mid]`和`a[mid+1..high]`两个区间, 求出左区间的最大元素lmax1和次大元素lmax2, 求出右区间的最大元素rmax1和次大元素rmax2.
   若`lmax1>rmax1`, 则`max1 = lmax1`, `max2 = max{lmax2, rmax1}`; 否则`max1 = rmax1`, `max2=max{lmax1, rmax2}`.

***代码实现***

```C++
void solve(int a[], int low, int high, int &max1, int &max2)
{
    if(low == high)								
    {
        max1 = a[low];
        max2 = -INF;
    }
    else if(low == high-1)
    {
        max1 = max(a[low], a[high]);
        max2 = min(a[low], a[high]);
    }
    else
    {
        int mid = (low+high)/2;
        int lmax1, lmax2;
        solve(a, low, mid, lmax1, lmax2);
        int rmax1, rmax2;
        solve(a, mid+1, high, rmax1, rmax2);
        if(lmax1 > rmax1)
        {
            max1 = lmax1;
            max2 = max(lmax2, rmax1);
        }
        else
        {
            max1 = rmax1;
            max2 = max(rmax2, lmax1);
        }
    }
    
}
```

***

   ##### 3.3.3 寻找一个序列中第k小的元素

***问题描述***

>  对于给定的含有n个元素的无序序列, 求这个序列中第k(1 <= k <= n)小的元素.

***问题求解***

对于无序序列`a[s..t]`,在其中查找第k小的元素的过程如下:

1. 若`s >= t`, 即其中只有一个元素或没有任何元素, 如果`s=t`或`s=k-1`,表示只有一个元素且`a[k-1]`就是要求的结果, 返回`a[k-1]`.

2. 若`s < t`, 表示该序列中有两个或两个以上的元素, 以基准为中心将其划分为`a[s..i-1]`和`a[i+1..t]`两个子序列, 基准`a[i]`已归位, `a[s..i-1]`中的所有元素均小于`a[i]`, `a[i+1..t]`中的所有元素均大于`a[i]`, 也就是说`a[i]`是第`i+1`小的元素, 有三种情况:

   * 若`k-1 = i `, `a[i]`即为所求, 返回`a[i]`.

   * 若`k-1 < i `, 第k小的元素应在`a[s..i-1]`子序列中, 递归在该子序列中求解并返回其结果.

   * 若`k-1 > i `, 第k小的元素应在`a[i+1..t]`子序列中, 递归在该子序列中求解并返回其结果.


***代码实现***

```C++
int QuickSelect(int a[], int s, int t, int k)
{
    int i =s, j = t;
    int tmp;
    if(s < t)
    {
        tmp = a[s];							//用区间的第1个记录作为基准
        while(i != j)
        {
            while(j > i && a[j] >= tmp)		j--;
            a[i] = a[j];
             while(i < j && a[i] <= tmp)	i++;
            a[j] = a[i];
        }
        a[i] = tmp;
        if(k-1 == i)	return a[i];
        else if(k-1 < i)	return QuickSelect(a, s, i-1, k);
        else QuickSelect(a, i+1, t, k);
    }
    else if(s == t && s == k-1)	return a[k-1];
}
```

***

##### 3.3.4 寻找两个等长有序序列的中位数

***问题描述***

> 对与一个长度为n的有序序列(假设均为升序序列)`a[0..n-1]`, 处于中间位置的元素称为a的中位数. 例如, 若序列`a = (11, 13, 15, 17, 19)`, 其中位数是15, 若`b = (2, 4, 6, 8, 20) `, 其中位数是6. 两个等长有序序列的中位数是含它们所有元素的有序序列的中位数, 例如a, b两个有序序列的中位数为11. 设计一个算法求给定的两个有序序列的中位数.

***问题求解***

含有n个元素的有序序列`a[s..t]`,  当n为奇数时, 中位数出现在`m = ⌊(s+t)/2⌋ `处; 当n为偶数时, 中位数下标有`m = ⌊(s+t)/2⌋ `(下中位)和`m = ⌊(s+t)/2⌋+1`(上中位)两个, 为了简单仅考虑 中位数下标为`m = ⌊(s+t)/2⌋ `.

采用二分法, 过程如下:

1. 分别求出a和b的中位数`a[m1]`和`b[m2]`.

2. 若`a[m1]=b[m2]`, 则`a[m1]`或`b[m2]`即为所求中位数, 算法结束.

3. 若`a[m1]<b[m2]`, 则舍弃序列a中的前半部分(较小的一半), 同时舍弃序列b中的后半部分(较大的一半), 要求舍弃的长度相等.

4. 若`a[m1]>b[m2]`, 则舍弃序列a中的后半部分(较大的一半), 同时舍弃序列b中的前半部分(较小的一半), 要求舍弃的长度相等.

   在保留的两个升序序列中重复上述过程直到两个序列中只含有一个元素时为止, 较小者即为所求的中位数.

***代码实现***

```C++
void prepart(int &s, int &t)			//求a[s..t]序列的前半子序列
{
    int m = (s+t)/2;
    t = m;
}
void postpart(int &s, int &t)			//求a[s..t]序列的后半子序列
{
    int m = (s+t)/2;
    if((s+t)%2==0)	s = m;				//序列中有奇数个元素
    else 			s = m+1;			//序列中有偶数个元素
}
int midnum(int a[], int s1, int t1, int b[], int s2, int t2)
{
    int m1, m2;
    if(s1==t1 && s2==t2)				//只有一个元素时返回较小者
    {
        return a[s1]<b[s2]?a[s1]:b[s2];
    }
    else
    {
        m1 = (s1+t1)/2;
        m2 = (s2+t2)/2;
        if(a[m1] == b[m2])	return a[m1];	//两中位数相等时返回该中位数
        if(a[m1] < b[m2])					//a[m1]<b[m2]时
        {
        	postpart(s1, t1);				//a取后半部分
            prepart(s2, t2);				//b取前半部分
            return midnum(a, s1, t1, b, s2, t2);
        }
        else								//a[m1]>b[m2]时
        {
            prepart(s1, t1);				//a取前半部分
            postpart(s2, t2);				//b取后半部分
            return midnum(a, s1, t1, b, s2, t2);
        }
    }
}
```

***

#### 3.4 求解组合问题

##### 3.4.1 求解最大连续子序列和问题

***问题描述***

>给定一个有n(n>=1)个整数的序列, 求出其中最大连续子序列的和. 例如序列`(-2, 11, -4, 13, -5, -2)`的最大子序列和为20. 规定一个序列的最大连续子序列和至少是0, 如果小于0, 其结果为0.

***问题求解***




#### 3.5 求解大整数乘法和矩阵乘法问题

***

### 第四章 蛮力法

#### 4.2 蛮力法的基本应用

#### 4.3 递归在蛮力法中的应用

***

### 第七章 贪心法

#### 7.2 求解活动安排问题

#### 7.3 求解背包问题

#### 7.4 求解最优装载问题

#### 7.5 求解田忌赛马问题

#### 7.6 求解多机调度问题



#### 7.7 哈夫曼编码

#### 7.8 求解流水作业调度问题

***

### 第八章 动态规划

#### 8.2 求解整数拆分问题



#### 8.3 求解最大连续子序列和问题

#### 8.4 求解三角形最小路径问题

#### 8.5 求解最长公共子序列问题

#### 8.6 求解最长递增子序列问题

#### 8.7 求解编辑距离问题

#### 8.8 求解0/1背包问题

#### 8.9 求解完全背包问题

#### 8.10 求解资源分配问题

#### 8.11 求解会议安排问题

#### 8.12 滚动数组







